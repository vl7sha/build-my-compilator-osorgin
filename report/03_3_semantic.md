## 3.3 Семантический анализ

Семантический анализ предназначен для выявления ошибок, которые невозможно обнаружить только синтаксисом (например, использование неописанных переменных или несоответствие типов).

На текущем этапе проекта режим работы зафиксирован как **«только ошибки лексики/синтаксиса»**, поэтому семантический анализ оформляется как следующий этап расширения (его правила и алгоритм фиксируются в отчёте, чтобы реализация была однозначной).

### 3.3.1 Семантические правила языка (набор проверок)

#### A) Описания (таблица символов)

Язык допускает объявления вида `idList : type`, где `type ∈ { %, !, $ }`.

Семантические проверки:
- **Повторное объявление**: идентификатор нельзя объявлять дважды.
- **Дубликаты в одном списке**: `a, a : %` — ошибка.
- **Порядок “описал → использовал”**: так как `program` допускает чередование `description` и `statement`, вводится правило: идентификатор может использоваться только после того, как он был объявлен в предшествующем элементе `description`.

#### B) Использование идентификаторов

- В `assignment` левый идентификатор обязан быть объявлен.
- В выражениях (`expr`) каждый `IDENT` обязан быть объявлен.
- В `read( ... )` каждый идентификатор обязан быть объявлен.

#### C) Система типов

В грамматике типы представлены символами `%`, `!`, `$`. Для типизации вводится интерпретация (может быть скорректирована под требования преподавателя, но в отчёте должна быть зафиксирована):
- `%` — **целый** тип (INT);
- `!` — **вещественный** тип (REAL);
- `$` — **логический** тип (BOOL).

Типы литералов:
- `INT_BIN/INT_OCT/INT_DEC/INT_HEX` → INT
- `REAL` → REAL
- `true/false` → BOOL

#### D) Типизация выражений (совместимость операций)

Выражения состоят из операций групп **отношения**, **сложения** и **умножения**, а также унарной операции `~`.

Правила:
- **Унарная `~`**: применяется только к BOOL, результат BOOL.
- **`plus`, `min`**: применяются только к числовым типам (INT/REAL), результат числовой.
  - если хотя бы один операнд REAL → результат REAL (неявное расширение INT → REAL);
  - иначе результат INT.
- **`mult`, `div`**: применяются только к числовым типам (INT/REAL), результат числовой.
  - для `div` рекомендуется результат REAL (чтобы не вводить целочисленное деление); это правило фиксируется в реализации;
  - для `mult` — как для `plus/min`.
- **`and`, `or`**: применяются только к BOOL, результат BOOL.
- **Операции отношений `NE/EQ/LT/LE/GT/GE`**:
  - допустимы сравнения числовых типов между собой (INT и REAL; INT расширяется до REAL);
  - сравнение BOOL допускается для `NE/EQ` (а для `LT/LE/GT/GE` запрещено);
  - результат любой операции отношения — BOOL.

Если тип операндов не подходит, формируется семантическая ошибка “несовместимые типы в операции …”.

#### E) Типизация операторов

- **Присваивание** `x ass expr`:
  - `x` должен быть объявлен;
  - тип `expr` должен быть совместим с типом `x`;
  - допускается неявное преобразование INT → REAL (если `x` имеет тип REAL).
- **Условный оператор** `if expr then ... [else ...]`:
  - `expr` должен иметь тип BOOL.
- **Цикл while** `while expr do ...`:
  - `expr` должен иметь тип BOOL.
- **Цикл for** `for (x ass e1) to e2 do ...`:
  - `x` должен быть объявлен;
  - `x`, `e1`, `e2` должны быть числовых типов;
  - рекомендуется ограничить управляющую переменную типом INT (классический “фиксированный” цикл), а `e1/e2` — приводить к INT; если это правило применяется, оно фиксируется в реализации и отражается в сообщениях об ошибках.
- **Ввод** `read(x1, x2, ...)`:
  - каждый `xi` должен быть объявлен;
  - типы могут быть любыми (INT/REAL/BOOL).
- **Вывод** `write(e1, e2, ...)`:
  - каждое выражение должно быть типизируемо (не содержать семантических ошибок, делающих тип “неизвестным”).

### 3.3.2 Алгоритм семантического анализа

Анализ выполняется обходом дерева разбора ANTLR (visitor):

1) **Обработка элементов программы слева направо** (`item`):
   - при встрече `description` — добавить имена в таблицу символов;
   - при встрече `statement` — проверить корректность идентификаторов и типов согласно правилам выше.

2) Для каждого поддерева выражения вычислить его тип снизу вверх:
   - `factor` → базовый тип (IDENT/число/BOOL/`~`/скобки);
   - `term/operand/expr` → проверка применимости операций и вычисление результирующего типа.

3) Ошибки не останавливают анализ: вместо “невыводимого” типа используется `UNKNOWN`, чтобы продолжать обход и собрать максимум диагностик за один запуск.

### 3.3.3 Представление ошибок

Для каждой семантической ошибки планируется формировать диагностику вида:
`<строка>:<столбец> <категория> <сообщение>`

где позиция берётся из токенов/узлов дерева разбора ANTLR.

Рекомендуемая детализация сообщения:
- имя идентификатора (если применимо);
- операция и фактические типы операндов;
- ожидаемое условие (например, “ожидался BOOL в условии if”).

